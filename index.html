<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy 2nd Anniversary</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap');

        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Roboto Mono', monospace; color: #fff; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* Video Container - Hidden by default or minimized */
        #video-container {
            position: absolute; bottom: 20px; left: 20px; width: 160px; height: 120px;
            z-index: 2; border-radius: 8px; overflow: hidden; opacity: 0.3;
            transform: scaleX(-1); /* Mirror view */
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: opacity 0.3s;
            display: none; /* Hide initially, can be toggled */
        }
        #video-container:hover { opacity: 1; }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        /* Loading Overlay */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #0091ff;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* UI Panels */
        .panel {
            position: absolute;
            background: rgba(10, 10, 10, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            z-index: 10;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        /* Control System Panel (Top Left) */
        #control-panel {
            top: 30px;
            left: 30px;
            width: 320px;
        }
        .panel-title {
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1.5px;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
        }
        .status-text {
            font-size: 14px;
            color: #0091ff;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .controls-list {
            font-size: 13px;
            color: #ddd;
            line-height: 1.8;
        }
        .control-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .icon { width: 16px; text-align: center; }

        /* Metrics Panel (Top Right) */
        #metrics-panel {
            top: 30px;
            right: 30px;
            width: 280px;
        }
        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 13px;
        }
        .metric-label { color: #888; }
        .metric-value { font-weight: 700; color: #fff; }
        
        /* Tension Bar */
        .tension-container {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }
        .tension-bar {
            height: 100%;
            background: #0091ff;
            width: 0%;
            transition: width 0.1s;
            box-shadow: 0 0 10px #0091ff;
        }

        /* Main Title */
        #main-title {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-family: "Times New Roman", serif;
            font-size: 30px;
            font-weight: bold;
            font-style: italic;
            letter-spacing: 2px;
            color: #fff;
            text-shadow: 0 0 10px #0091ff, 0 0 20px #0091ff, 0 0 40px #0091ff, 0 0 80px #0091ff;
            z-index: 10;
            pointer-events: none;
            text-transform: uppercase;
            opacity: 1;
            transition: opacity 0.5s;
            white-space: nowrap;
            text-align: center;
        }

        /* Bottom Navigation */
        #bottom-nav {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px 20px;
            background: rgba(10, 10, 10, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 10;
        }
        
        .color-picker-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            cursor: pointer;
            background: #0091ff;
            transition: transform 0.2s;
            position: relative;
            overflow: hidden;
        }
        .color-picker-btn:hover { transform: scale(1.1); }
        .color-picker-btn input {
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            opacity: 0;
            cursor: pointer;
        }

        .shape-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
            padding: 8px 16px;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .shape-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .shape-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
            font-weight: 700;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* Gallery Styles */
        #gallery-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none;
            display: flex; justify-content: center; align-items: center;
            perspective: 1200px;
            opacity: 0; transition: opacity 0.5s;
        }
        .gallery-card {
            position: absolute;
            width: 50vw; height: 60vh;
            max-width: 800px; max-height: 600px;
            background-size: cover; background-position: center;
            border-radius: 16px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), filter 0.4s, opacity 0.4s;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: #000;
            /* Performance optimizations */
            backface-visibility: hidden;
            will-change: transform;
        }
        .gallery-card.center {
            z-index: 10;
            transform: translate3d(0, 0, 0);
            filter: none;
            opacity: 1;
            border: 2px solid rgba(255, 255, 255, 0.8);
        }
        .gallery-card.left {
            z-index: 5;
            transform: translate3d(-60%, 0, -300px) rotateY(35deg);
            filter: blur(8px) brightness(0.4) grayscale(0.5);
            opacity: 0.6;
        }
        .gallery-card.right {
            z-index: 5;
            transform: translate3d(60%, 0, -300px) rotateY(-35deg);
            filter: blur(8px) brightness(0.4) grayscale(0.5);
            opacity: 0.6;
        }

        /* Karaoke Text */
        #karaoke-container {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .karaoke-line {
            font-size: 24px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.3);
            transition: all 0.5s;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            max-width: 80%;
        }
        .karaoke-line.active {
            color: #fff;
            font-size: 28px;
            text-shadow: 0 0 10px #0091ff, 0 0 20px #0091ff, 0 0 40px #0091ff;
            transform: scale(1.05);
        }
        .karaoke-line.highlight {
            background: linear-gradient(90deg, #fff 0%, #fff 50%, rgba(255,255,255,0.3) 50%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: karaoke-wipe 4s linear forwards;
        }
        @keyframes karaoke-wipe {
            from { background-position: 100% 0; }
            to { background-position: 0% 0; }
        }

    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner"></div>
        <div>ƒêang kh·ªüi t·∫°o AI & Hi·ªáu ·ª©ng...</div>
    </div>

    <!-- Main Title -->
    <div id="main-title">
        Happy 2nd Anniversary<br>
        <small>Anhrighthere & Phunolg</small>
    </div>

    <!-- Control System Panel -->
    <div id="control-panel" class="panel">
        <div class="panel-title">H∆∞·ªõng D·∫´n ƒêi·ªÅu Khi·ªÉn</div>
        <div id="system-status" class="status-text">ƒêang kh·ªüi ƒë·ªông Camera...</div>
        <div class="controls-list">
            <div class="control-item"><span class="icon">‚úã</span> ƒê∆∞a tay l√™n tr∆∞·ªõc Camera ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
            <div class="control-item"><span class="icon">‚ÜîÔ∏è</span> M·ªü r·ªông hai tay: ƒê·ªÉ xem th√¥ng ƒëi·ªáp</div>
            <div class="control-item"><span class="icon">üëã</span> Di chuy·ªÉn tay: Xoay kh·ªëi 3D & Xem ·∫£nh</div>
        </div>
    </div>

    <!-- Metrics Panel -->
    <div id="metrics-panel" class="panel">
        <div class="panel-title" style="text-align: right;">Metrics</div>
        
        <div class="metric-row">
            <span class="metric-label">TENSION</span>
            <span id="tension-value" class="metric-value">0%</span>
        </div>
        <div class="tension-container">
            <div id="tension-bar" class="tension-bar"></div>
        </div>
        
        <div class="metric-row" style="margin-top: 15px;">
            <span class="metric-label">PARTICLES</span>
            <span class="metric-value">15,000</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">INPUT</span>
            <span id="input-mode" class="metric-value">MOUSE</span>
        </div>
        <div class="metric-row">
            <span class="metric-label">FPS</span>
            <span id="fps-counter" class="metric-value">60</span>
        </div>
    </div>

    <!-- Bottom Navigation -->
    <div id="bottom-nav">
        <div class="color-picker-btn" id="color-btn">
            <input type="color" id="color-input" value="#0091ff">
        </div>
        <button class="shape-btn active" data-shape="Heart">Heart</button>
        <button class="shape-btn" data-shape="Flower">Flower</button>
        <button class="shape-btn" data-shape="Saturn">Saturn</button>
        <button class="shape-btn" data-shape="Fireworks">Bang</button>
        <button id="music-btn" class="shape-btn">Music: OFF</button>
    </div>

    <!-- Audio Element -->
    <audio id="bg-music" loop>
        <source src="audio.mp3" type="audio/mpeg">
    </audio>

    <!-- Webcam Feed (Visual Feedback) -->
    <div id="video-container">
        <video id="input-video" autoplay playsinline muted></video>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Gallery Overlay -->
    <div id="gallery-container">
        <div class="gallery-card left" id="img-left"></div>
        <div class="gallery-card center" id="img-center"></div>
        <div class="gallery-card right" id="img-right"></div>
        
        <div id="karaoke-container">
            <div id="karaoke-line-1" class="karaoke-line"></div>
            <div id="karaoke-line-2" class="karaoke-line"></div>
        </div>
    </div>

    <!-- Dependencies: Three.js, MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
                "@mediapipe/drawing_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = []; // Where particles want to go
        let randomOffsets = []; // Random vectors for galaxy scatter effect
        let heartLayer = []; // 0 = inner, 1 = outer
        const PARTICLE_COUNT = 15000;
        let currentShape = 'Heart';
        let handDistance = 0.5; // Normalized 0 to 1
        let isHandDetected = false;
        let smoothedScale = 1.0;
        let targetRotationX = 0;
        let rotationVelocity = 0.002;
        let previousHandX = null;
        let musicTriggeredByGalaxy = false;
        
        // Karaoke Data
        const karaokeLyrics = [
            { text: "Thanh Ph∆∞∆°ng √†, v·∫≠y l√† m√¨nh ƒë√£ ƒëi c√πng nhau tr√≤n 2 nƒÉm r·ªìi ƒë√≥ ‚ù§Ô∏è", duration: 5000 },
            { text: "Anh mu·ªën n√≥i l·ªùi c·∫£m ∆°n em, v√¨ su·ªët qu√£ng th·ªùi gian ·∫•y", duration: 5000 },
            { text: "em ƒë√£ ·ªü b√™n anh b·∫±ng t·∫•t c·∫£ s·ª± d·ªãu d√†ng, ki√™n nh·∫´n v√† y√™u th∆∞∆°ng.", duration: 5000 },
            { text: "C·∫£m ∆°n em v√¨ nh·ªØng l√∫c vui c√≥ nhau ƒë·ªÉ c∆∞·ªùi th·∫≠t to", duration: 4000 },
            { text: "v√† c·∫£ nh·ªØng l√∫c bu·ªìn, m·ªát m·ªèi, v·∫´n ch·ªçn n·∫Øm tay anh m√† kh√¥ng r·ªùi ƒëi.", duration: 5000 },
            { text: "C·∫£m ∆°n em v√¨ ƒë√£ y√™u anh kh√¥ng ch·ªâ khi anh t·ªët nh·∫•t", duration: 4000 },
            { text: "m√† c·∫£ khi anh v·ª•ng v·ªÅ, thi·∫øu s√≥t v√† ch∆∞a ho√†n h·∫£o.", duration: 4000 },
            { text: "2 nƒÉm kh√¥ng ph·∫£i l√† qu√° d√†i cho c·∫£ m·ªôt ƒë·ªùi ng∆∞·ªùi", duration: 4000 },
            { text: "nh∆∞ng ƒë·ªß d√†i ƒë·ªÉ anh ch·∫Øc ch·∫Øn m·ªôt ƒëi·ªÅu:", duration: 3000 },
            { text: "c√≥ em b√™n c·∫°nh, m·ªçi th·ª© ƒë·ªÅu tr·ªü n√™n ƒë√°ng gi√° h∆°n.", duration: 4000 },
            { text: "Anh mong r·∫±ng sau 2 nƒÉm n√†y, m√¨nh s·∫Ω c√≤n th√™m r·∫•t nhi·ªÅu nƒÉm n·ªØa", duration: 5000 },
            { text: "v·∫´n l√† Thanh Ph∆∞∆°ng v√† Tu·∫•n Anh, v·∫´n c√πng nhau m·ªói ng√†y", duration: 4000 },
            { text: "v·∫´n th∆∞∆°ng nhau theo c√°ch gi·∫£n d·ªã nh∆∞ng ch√¢n th√†nh nh·∫•t.", duration: 4000 },
            { text: "C·∫£m ∆°n em v√¨ ƒë√£ ƒë·∫øn, ƒë√£ ·ªü l·∫°i v√† ƒë√£ y√™u anh üíï", duration: 5000 },
            { text: "Anh y√™u em, kh√¥ng ch·ªâ h√¥m nay, m√† l√† c·∫£ ch·∫∑ng ƒë∆∞·ªùng ph√≠a tr∆∞·ªõc.", duration: 5000 }
        ];
        let karaokeStartTime = 0;
        let karaokePausedTime = 0;
        let currentKaraokeIndex = -1;

        // Gallery Data
        const imageList = [
            'TAN_6262.jpg', 'TAN_6328.jpg', 'TAN_6354.jpg', 'TAN_6403.jpg', 
            'TAN_6410.jpg', 'TAN_6432.jpg', 'TAN_6539.jpg', 'TAN_6584.jpg', 
            'TAN_6678.jpg', 'TAN_6694.jpg'
        ];
        let currentImageIndex = 0;
        let lastGalleryUpdate = 0;

        // FPS Counter
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        // --- CONFIGURATION ---
        const config = {
            shape: 'Heart',
            color: '#0091ff', // Updated default color to match UI
            particleSize: 0.15,
            rotationSpeed: 0.2,
            responsiveness: 0.1 // Lerp speed
        };

        // --- PRELOAD IMAGES ---
        function preloadImages() {
            imageList.forEach(filename => {
                const img = new Image();
                img.src = `pictures/${filename}`;
            });
        }

        // --- INIT THREE.JS ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            createParticleSystem();
            setupUI();

            window.addEventListener('resize', onWindowResize);
            
            animate();
        }

        // --- PARTICLE SYSTEM ---
        function createParticleSystem() {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            randomOffsets = new Float32Array(PARTICLE_COUNT * 3);
            heartLayer = new Float32Array(PARTICLE_COUNT);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            
            const initialColor = new THREE.Color(config.color);

            // Initial Random Positions
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;

                // Initialize colors
                colors[i * 3] = initialColor.r;
                colors[i * 3 + 1] = initialColor.g;
                colors[i * 3 + 2] = initialColor.b;

                // Generate random scatter vectors for galaxy effect
                // Spread more horizontally for a disc-like galaxy feel
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 10 + Math.random() * 40; // Random radius
                
                randomOffsets[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                randomOffsets[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                randomOffsets[i * 3 + 2] = r * Math.cos(phi);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Generate Soft Glow Texture Procedurally
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);

            material = new THREE.PointsMaterial({
                color: 0xffffff, // Use white to allow vertex colors to show through
                vertexColors: true,
                size: config.particleSize,
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Generate initial target
            generateTargetPositions(config.shape);
        }

        // --- SHAPE GENERATORS ---
        function generateTargetPositions(shapeType) {
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;

                if (shapeType === 'Heart') {
                    // Parametric Heart
                    const t = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI; 
                    // 3D Heart approximation
                    x = 16 * Math.pow(Math.sin(t), 3) * Math.sin(phi);
                    y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * Math.sin(phi);
                    z = 6 * Math.cos(phi); 
                    
                    // Nested Heart: Inner (0.5) and Outer (0.8)
                    const isInner = Math.random() < 0.5;
                    const scale = isInner ? 0.5 : 0.8;
                    x *= scale; y *= scale; z *= scale;
                    
                    heartLayer[i] = isInner ? 0 : 1;
                } 
                else {
                    heartLayer[i] = 0; // Reset for other shapes
                    
                    if (shapeType === 'Saturn') {
                        const r = Math.random();
                        if (r < 0.3) {
                            // Planet Body
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos(2 * Math.random() - 1);
                            const rad = 4;
                            x = rad * Math.sin(phi) * Math.cos(theta);
                            y = rad * Math.sin(phi) * Math.sin(theta);
                            z = rad * Math.cos(phi);
                        } else {
                            // Rings
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 6 + Math.random() * 6;
                            x = Math.cos(angle) * dist;
                            y = (Math.random() - 0.5) * 0.5; // Thin ring
                            z = Math.sin(angle) * dist;
                            // Tilt ring
                            const tilt = 0.4;
                            const yt = y * Math.cos(tilt) - z * Math.sin(tilt);
                            const zt = y * Math.sin(tilt) + z * Math.cos(tilt);
                            y = yt; z = zt;
                        }
                    }
                    else if (shapeType === 'Flower') {
                        const u = Math.random() * Math.PI * 2;
                        const v = Math.random() * Math.PI;
                        const r = 5 * (1 + 0.5 * Math.sin(5 * u) * Math.sin(5 * v));
                        x = r * Math.sin(v) * Math.cos(u);
                        y = r * Math.sin(v) * Math.sin(u);
                        z = r * Math.cos(v);
                    }
                    else if (shapeType === 'Fireworks') {
                        // Sphere explosion
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        const rad = Math.random() * 15;
                        x = rad * Math.sin(phi) * Math.cos(theta);
                        y = rad * Math.sin(phi) * Math.sin(theta);
                        z = rad * Math.cos(phi);
                    }
                }

                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;
            }
        }

        // --- UI SETUP ---
        function setupUI() {
            // Shape Buttons
            // Only select buttons that actually control shapes (exclude music button)
            const buttons = document.querySelectorAll('.shape-btn[data-shape]');
            buttons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Remove active class from all shape buttons
                    buttons.forEach(b => b.classList.remove('active'));
                    // Add to clicked
                    e.target.classList.add('active');
                    
                    const shape = e.target.dataset.shape;
                    config.shape = shape;
                    generateTargetPositions(shape);
                });
            });

            // Color Picker
            const colorInput = document.getElementById('color-input');
            const colorBtn = document.getElementById('color-btn');
            
            colorInput.addEventListener('input', (e) => {
                const color = e.target.value;
                config.color = color;
                // material.color.set(color); // Removed to allow vertex colors to control color
                colorBtn.style.background = color;
                
                // Update tension bar color too
                document.getElementById('tension-bar').style.background = color;
                document.getElementById('tension-bar').style.boxShadow = `0 0 10px ${color}`;
            });
        }

        // --- GALLERY UPDATE ---
        function updateGallery() {
            const container = document.getElementById('gallery-container');
            const leftCard = document.getElementById('img-left');
            const centerCard = document.getElementById('img-center');
            const rightCard = document.getElementById('img-right');

            if (!container || !leftCard || !centerCard || !rightCard) return;

            // Calculate indices with wrapping
            const total = imageList.length;
            const leftIndex = (currentImageIndex - 1 + total) % total;
            const rightIndex = (currentImageIndex + 1) % total;

            // Update Image Sources
            leftCard.style.backgroundImage = `url('pictures/${imageList[leftIndex]}')`;
            centerCard.style.backgroundImage = `url('pictures/${imageList[currentImageIndex]}')`;
            rightCard.style.backgroundImage = `url('pictures/${imageList[rightIndex]}')`;
        }

        // --- ANIMATION LOOP ---
        function animate(time) {
            requestAnimationFrame(animate);

            // FPS Calculation
            if (time) {
                const now = time * 0.001;
                frameCount++;
                if (now - lastFpsTime >= 1.0) {
                    document.getElementById('fps-counter').innerText = frameCount;
                    frameCount = 0;
                    lastFpsTime = now;
                }
            }

            const positions = particles.geometry.attributes.position.array;

            // Hand Control Logic
            // If hands are detected: Map distance (0 to 1) to Scale (0.1 to 2.5)
            // If hands are close (0.1), scale is small (compressed). 
            // If hands are far (0.8+), scale is large.
            let targetScale = 1.0;
            
            if (isHandDetected) {
                // Determine scale based on hand distance
                // handDistance typically ranges 0.05 (touching) to 0.8 (arms spread)
                targetScale = 1 + (handDistance * 3.0); 
                
                // Update UI
                document.getElementById('input-mode').innerText = "HANDS";
                document.getElementById('input-mode').style.color = "#0091ff";
            } else {
                // Idle breathing animation if no hands
                targetScale = 1.0 + Math.sin(Date.now() * 0.002) * 0.1;
                
                // Update UI
                document.getElementById('input-mode').innerText = "MOUSE";
                document.getElementById('input-mode').style.color = "#fff";
            }

            // Smooth the scale transition
            smoothedScale += (targetScale - smoothedScale) * 0.08;

            // Update Tension UI
            // Map scale (approx 0.5 to 3.5) to percentage (0 to 100)
            const tensionPercent = Math.min(100, Math.max(0, (smoothedScale - 0.5) / 3.0 * 100));
            document.getElementById('tension-bar').style.width = `${tensionPercent}%`;
            document.getElementById('tension-value').innerText = `${Math.round(tensionPercent)}%`;

            // Lerp factor
            const lerpSpeed = 0.05;

            // Calculate scatter factor based on scale
            // When scale > 1.5 (hands opening), start scattering
            // Max scatter at scale 3.0
            let scatterFactor = 0;
            if (smoothedScale > 2.8) {
                scatterFactor = (smoothedScale - 1.5) / 1.5; // 0 to 1
                scatterFactor = Math.min(1, scatterFactor);
            }

            // --- COLOR CHANGE LOGIC ---
            // Handled per-particle in the loop below

            // --- GALLERY LOGIC ---
            const galleryContainer = document.getElementById('gallery-container');
            // Exclude #main-title so it remains visible during galaxy effect
            const uiPanels = document.querySelectorAll('.panel, #bottom-nav');

            if (galleryContainer) {
                if (scatterFactor > 0.5) {
                    // Auto-play music on first scatter
                    if (!musicTriggeredByGalaxy) {
                        const audio = document.getElementById('bg-music');
                        const musicBtn = document.getElementById('music-btn');
                        if (audio && audio.paused) {
                            audio.play().then(() => {
                                if (musicBtn) {
                                    musicBtn.innerText = "Music: ON";
                                    musicBtn.classList.add('active');
                                }
                            }).catch(err => console.error("Auto-play failed:", err));
                        }
                        musicTriggeredByGalaxy = true;
                    }

                    // Show Gallery
                    galleryContainer.style.opacity = '1';
                    galleryContainer.style.pointerEvents = 'auto';
                    
                    // Karaoke Logic
                    if (karaokeStartTime === 0) {
                        karaokeStartTime = Date.now() - karaokePausedTime;
                    }
                    
                    const elapsedTime = Date.now() - karaokeStartTime;
                    let accumulatedTime = 0;
                    let activeIndex = -1;
                    
                    for (let i = 0; i < karaokeLyrics.length; i++) {
                        if (elapsedTime >= accumulatedTime && elapsedTime < accumulatedTime + karaokeLyrics[i].duration) {
                            activeIndex = i;
                            break;
                        }
                        accumulatedTime += karaokeLyrics[i].duration;
                    }
                    
                    // Loop if finished
                    if (activeIndex === -1 && elapsedTime > accumulatedTime) {
                        karaokeStartTime = Date.now(); // Restart
                        activeIndex = 0;
                    }
                    
                    if (activeIndex !== currentKaraokeIndex) {
                        currentKaraokeIndex = activeIndex;
                        const line1 = document.getElementById('karaoke-line-1');
                        const line2 = document.getElementById('karaoke-line-2');
                        
                        if (line1 && line2 && activeIndex !== -1) {
                            const currentLyric = karaokeLyrics[activeIndex];
                            const nextLyric = karaokeLyrics[(activeIndex + 1) % karaokeLyrics.length];
                            
                            line1.innerText = currentLyric.text;
                            line1.classList.remove('active', 'highlight');
                            void line1.offsetWidth; // Trigger reflow
                            line1.classList.add('active', 'highlight');
                            line1.style.animationDuration = `${currentLyric.duration}ms`;
                            
                            line2.innerText = nextLyric.text;
                            line2.classList.remove('active', 'highlight');
                        }
                    }
                    
                    // Hide UI
                    uiPanels.forEach(el => {
                        el.style.opacity = '0';
                        el.style.pointerEvents = 'none';
                        el.style.transition = 'opacity 0.5s';
                    });

                    // Initialize gallery if needed (first show)
                    if (galleryContainer.style.opacity === '1' && !galleryContainer.dataset.initialized) {
                        updateGallery();
                        galleryContainer.dataset.initialized = 'true';
                    }

                    // Navigate based on rotation velocity (Hand Swipe)
                    const now = Date.now();
                    
                    // Dynamic debounce based on speed for smoother scrolling
                    // Faster hand movement = faster image switching
                    const speed = Math.abs(rotationVelocity);
                    // Map speed (0.02 to 0.15) to delay (300ms to 50ms)
                    let dynamicDelay = 300 - ((speed - 0.02) * 2000);
                    dynamicDelay = Math.max(50, Math.min(300, dynamicDelay));

                    if (now - lastGalleryUpdate > dynamicDelay) { 
                        // Threshold for swipe detection
                        if (rotationVelocity > 0.015) {
                            // Swipe Right -> Previous Image
                            currentImageIndex = (currentImageIndex - 1 + imageList.length) % imageList.length;
                            updateGallery();
                            lastGalleryUpdate = now;
                        } else if (rotationVelocity < -0.015) {
                            // Swipe Left -> Next Image
                            currentImageIndex = (currentImageIndex + 1) % imageList.length;
                            updateGallery();
                            lastGalleryUpdate = now;
                        }
                    }
                } else {
                    // Hide Gallery
                    galleryContainer.style.opacity = '0';
                    galleryContainer.style.pointerEvents = 'none';

                    // Pause Karaoke
                    if (karaokeStartTime > 0) {
                        karaokePausedTime = Date.now() - karaokeStartTime;
                        karaokeStartTime = 0;
                    }

                    // Show UI
                    uiPanels.forEach(el => {
                        el.style.opacity = '1';
                        el.style.pointerEvents = 'auto';
                        el.style.transition = 'opacity 0.5s';
                    });
                }
            }

            // Beat Logic for Heart
            const beatScale = 1.0 + 0.05 * Math.sin(Date.now() * 0.005);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // Calculate target with scale
                let tx = targetPositions[ix] * smoothedScale;
                let ty = targetPositions[iy] * smoothedScale;
                let tz = targetPositions[iz] * smoothedScale;

                // Apply Heart Beat to Outer Layer
                if (config.shape === 'Heart' && heartLayer[i] === 1) {
                    tx *= beatScale;
                    ty *= beatScale;
                    tz *= beatScale;
                }

                // Apply galaxy scatter effect
                if (scatterFactor > 0) {
                    tx += randomOffsets[ix] * scatterFactor;
                    ty += randomOffsets[iy] * scatterFactor;
                    tz += randomOffsets[iz] * scatterFactor;
                }

                // Move current position towards target
                positions[ix] += (tx - positions[ix]) * lerpSpeed;
                positions[iy] += (ty - positions[iy]) * lerpSpeed;
                positions[iz] += (tz - positions[iz]) * lerpSpeed;

                // --- COLOR INTERPOLATION ---
                const rIndex = i * 3;
                const currentR = particles.geometry.attributes.color.array[rIndex];
                const currentG = particles.geometry.attributes.color.array[rIndex+1];
                const currentB = particles.geometry.attributes.color.array[rIndex+2];
                
                let targetR, targetG, targetB;
                
                if (scatterFactor > 0) {
                    // Galaxy Scatter -> White
                    targetR = 1; targetG = 1; targetB = 1;
                } else {
                    // Default -> Config Color
                    const c = new THREE.Color(config.color);
                    targetR = c.r; targetG = c.g; targetB = c.b;
                }
                
                // Lerp color
                particles.geometry.attributes.color.array[rIndex] += (targetR - currentR) * 0.1;
                particles.geometry.attributes.color.array[rIndex+1] += (targetG - currentG) * 0.1;
                particles.geometry.attributes.color.array[rIndex+2] += (targetB - currentB) * 0.1;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            
            // Apply rotation velocity
            particles.rotation.y += rotationVelocity;
            
            // Keep X rotation stable (0)
            particles.rotation.x += (0 - particles.rotation.x) * 0.05;

            // Friction / Inertia Logic
            if(!isHandDetected) {
                // Decelerate due to friction
                rotationVelocity *= 0.98;
                
                // Maintain a minimum idle rotation
                if (Math.abs(rotationVelocity) < 0.002) {
                    rotationVelocity = 0.002;
                }
            } else {
                // While hand is detected, velocity is controlled by hand movement (in onHandsResults)
                // We add a slight decay here too so it doesn't spin forever if hand stops moving but is still detected
                // This simulates "holding" the object
                rotationVelocity *= 0.90; 
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MEDIAPIPE HAND TRACKING ---
        function initMediaPipe() {
            const videoElement = document.getElementById('input-video');
            const statusText = document.getElementById('system-status');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.8,
                minTrackingConfidence: 0.8
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loader').style.opacity = '0';
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                    statusText.innerText = "Camera ƒê√£ B·∫≠t. Theo D√µi Tay ƒêang Ch·∫°y.";
                    statusText.style.color = "#0091ff";
                })
                .catch(err => {
                    console.error("Camera error:", err);
                    alert("Kh√¥ng th·ªÉ truy c·∫≠p Camera ho·∫∑c c√≥ l·ªói. Hi·ªáu ·ª©ng s·∫Ω ch·∫°y ·ªü ch·∫ø ƒë·ªô t·ª± ƒë·ªông.");
                    document.getElementById('loader').style.display = 'none';
                    statusText.innerText = "Kh√¥ng Th·ªÉ Truy C·∫≠p Camera. Ch·∫ø ƒê·ªô Chu·ªôt ƒê√£ B·∫≠t.";
                    statusText.style.color = "#ff5555";
                });
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                
                let totalOpenness = 0;
                let avgX = 0;
                let avgY = 0;
                
                for (const landmarks of results.multiHandLandmarks) {
                    // Calculate hand openness based on wrist-to-fingertip vs wrist-to-knuckle ratio
                    // Wrist: 0, Middle Finger MCP: 9, Middle Finger Tip: 12
                    const wrist = landmarks[0];
                    const middleMcp = landmarks[9];
                    const middleTip = landmarks[12];
                    
                    // Distance from wrist to knuckle (hand size reference)
                    const handSize = Math.sqrt(
                        Math.pow(middleMcp.x - wrist.x, 2) + 
                        Math.pow(middleMcp.y - wrist.y, 2)
                    );
                    
                    // Distance from wrist to finger tip
                    const fingerExtension = Math.sqrt(
                        Math.pow(middleTip.x - wrist.x, 2) + 
                        Math.pow(middleTip.y - wrist.y, 2)
                    );
                    
                    // Ratio: ~2.0+ for open hand, ~1.0 or less for fist
                    const ratio = fingerExtension / (handSize || 0.01);
                    totalOpenness += ratio;

                    // Accumulate position for centroid
                    avgX += wrist.x;
                    avgY += wrist.y;
                }
                
                const avgOpenness = totalOpenness / results.multiHandLandmarks.length;
                
                // Map ratio to 0..1 range
                // Fist (approx 0.8-1.0) -> 0
                // Open (approx 2.0-2.5) -> 1
                const minOpen = 1.0;
                const maxOpen = 2.2;
                
                let normalized = (avgOpenness - minOpen) / (maxOpen - minOpen);
                handDistance = Math.max(0, Math.min(1, normalized));

                // Calculate average position
                avgX /= results.multiHandLandmarks.length;
                avgY /= results.multiHandLandmarks.length;

                // Calculate velocity based on hand movement
                if (previousHandX !== null) {
                    // Sensitivity factor for "flick"
                    const deltaX = avgX - previousHandX;
                    
                    // Add impulse to rotation velocity
                    // We use a weighted average to smooth out jitter but respond quickly to flicks
                    // Multiplier 20.0 makes it responsive
                    const targetVel = deltaX * 5.0;
                    
                    // If moving fast, take over velocity. If moving slow, blend.
                    if (Math.abs(targetVel) > Math.abs(rotationVelocity)) {
                        rotationVelocity = targetVel;
                    } else {
                        rotationVelocity += (targetVel - rotationVelocity) * 0.2;
                    }
                }
                previousHandX = avgX;

            } else {
                isHandDetected = false;
                previousHandX = null;
            }
        }

        // --- AUDIO SETUP ---
        function setupAudio() {
            const audio = document.getElementById('bg-music');
            const musicBtn = document.getElementById('music-btn');
            
            if(audio && musicBtn) {
                audio.volume = 0.5; // Set default volume to 50%

                musicBtn.addEventListener('click', () => {
                    if (audio.paused) {
                        audio.play().then(() => {
                            musicBtn.innerText = "Music: ON";
                            musicBtn.classList.add('active');
                        }).catch(err => {
                            console.error("Audio play failed:", err);
                        });
                    } else {
                        audio.pause();
                        musicBtn.innerText = "Music: OFF";
                        musicBtn.classList.remove('active');
                    }
                });
            }
        }

        // --- BOOTSTRAP ---
        window.onload = () => {
            preloadImages();
            initThree();
            initMediaPipe();
            setupAudio();
        };

    </script>
</body>
</html>